// Code generated by "go-enum -type=Icon"; DO NOT EDIT.

// Install go-enum by `go get install github.com/searKing/golang/tools/go-enum`
package model

import (
	"database/sql"
	"database/sql/driver"
	"encoding"
	"encoding/json"
	"fmt"
	"strconv"
)

func _() {
	// An "invalid array index" compiler error signifies that the constant values have changed.
	// Re-run the stringer command to generate them again.
	var x [1]struct{}
	_ = x[Unknown-0]
	_ = x[Bear-1]
	_ = x[Bird-2]
	_ = x[Bug-3]
	_ = x[Butterfly-4]
	_ = x[Cat-5]
	_ = x[Cow-6]
	_ = x[Crab-7]
	_ = x[Elephant-8]
	_ = x[Fish-9]
	_ = x[Frog-10]
	_ = x[Hedgehog-11]
	_ = x[Horse-12]
	_ = x[Lion-13]
	_ = x[Narwhal-14]
	_ = x[Owl-15]
	_ = x[Pig-16]
	_ = x[Rabbit-17]
	_ = x[Shark-18]
	_ = x[Snail-19]
	_ = x[Squirrel-20]
	_ = x[Rat-21]
	_ = x[Turtle-22]
	_ = x[Worm-23]
	_ = x[Whale-24]
}

const _Icon_name = "UnknownBearBirdBugButterflyCatCowCrabElephantFishFrogHedgehogHorseLionNarwhalOwlPigRabbitSharkSnailSquirrelRatTurtleWormWhale"

var _Icon_index = [...]uint8{0, 7, 11, 15, 18, 27, 30, 33, 37, 45, 49, 53, 61, 66, 70, 77, 80, 83, 89, 94, 99, 107, 110, 116, 120, 125}

func _() {
	var _nil_Icon_value = func() (val Icon) { return }()

	// An "cannot convert Icon literal (type Icon) to type fmt.Stringer" compiler error signifies that the base type have changed.
	// Re-run the go-enum command to generate them again.
	var _ fmt.Stringer = _nil_Icon_value
}

func (i Icon) String() string {
	if i < 0 || i >= Icon(len(_Icon_index)-1) {
		return "Icon(" + strconv.FormatInt(int64(i), 10) + ")"
	}
	return _Icon_name[_Icon_index[i]:_Icon_index[i+1]]
}

// New returns a pointer to a new addr filled with the Icon value passed in.
func (i Icon) New() *Icon {
	clone := i
	return &clone
}

var _Icon_values = []Icon{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24}

var _Icon_name_to_values = map[string]Icon{
	_Icon_name[0:7]:     0,
	_Icon_name[7:11]:    1,
	_Icon_name[11:15]:   2,
	_Icon_name[15:18]:   3,
	_Icon_name[18:27]:   4,
	_Icon_name[27:30]:   5,
	_Icon_name[30:33]:   6,
	_Icon_name[33:37]:   7,
	_Icon_name[37:45]:   8,
	_Icon_name[45:49]:   9,
	_Icon_name[49:53]:   10,
	_Icon_name[53:61]:   11,
	_Icon_name[61:66]:   12,
	_Icon_name[66:70]:   13,
	_Icon_name[70:77]:   14,
	_Icon_name[77:80]:   15,
	_Icon_name[80:83]:   16,
	_Icon_name[83:89]:   17,
	_Icon_name[89:94]:   18,
	_Icon_name[94:99]:   19,
	_Icon_name[99:107]:  20,
	_Icon_name[107:110]: 21,
	_Icon_name[110:116]: 22,
	_Icon_name[116:120]: 23,
	_Icon_name[120:125]: 24,
}

// ParseIconString retrieves an enum value from the enum constants string name.
// Throws an error if the param is not part of the enum.
func ParseIconString(s string) (Icon, error) {
	if val, ok := _Icon_name_to_values[s]; ok {
		return val, nil
	}
	return 0, fmt.Errorf("%s does not belong to Icon values", s)
}

// IconValues returns all values of the enum
func IconValues() []Icon {
	return _Icon_values
}

// IsAIcon returns "true" if the value is listed in the enum definition. "false" otherwise
func (i Icon) Registered() bool {
	for _, v := range _Icon_values {
		if i == v {
			return true
		}
	}
	return false
}

func _() {
	var _nil_Icon_value = func() (val Icon) { return }()

	// An "cannot convert Icon literal (type Icon) to type encoding.BinaryMarshaler" compiler error signifies that the base type have changed.
	// Re-run the go-enum command to generate them again.
	var _ encoding.BinaryMarshaler = &_nil_Icon_value

	// An "cannot convert Icon literal (type Icon) to type encoding.BinaryUnmarshaler" compiler error signifies that the base type have changed.
	// Re-run the go-enum command to generate them again.
	var _ encoding.BinaryUnmarshaler = &_nil_Icon_value
}

// MarshalBinary implements the encoding.BinaryMarshaler interface for Icon
func (i Icon) MarshalBinary() (data []byte, err error) {
	return []byte(i.String()), nil
}

// UnmarshalBinary implements the encoding.BinaryUnmarshaler interface for Icon
func (i *Icon) UnmarshalBinary(data []byte) error {
	var err error
	*i, err = ParseIconString(string(data))
	return err
}

func _() {
	var _nil_Icon_value = func() (val Icon) { return }()

	// An "cannot convert Icon literal (type Icon) to type json.Marshaler" compiler error signifies that the base type have changed.
	// Re-run the go-enum command to generate them again.
	var _ json.Marshaler = _nil_Icon_value

	// An "cannot convert Icon literal (type Icon) to type encoding.Unmarshaler" compiler error signifies that the base type have changed.
	// Re-run the go-enum command to generate them again.
	var _ json.Unmarshaler = &_nil_Icon_value
}

// MarshalJSON implements the json.Marshaler interface for Icon
func (i Icon) MarshalJSON() ([]byte, error) {
	return json.Marshal(i.String())
}

// UnmarshalJSON implements the json.Unmarshaler interface for Icon
func (i *Icon) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return fmt.Errorf("Icon should be a string, got %s", data)
	}

	var err error
	*i, err = ParseIconString(s)
	return err
}

func _() {
	var _nil_Icon_value = func() (val Icon) { return }()

	// An "cannot convert Icon literal (type Icon) to type encoding.TextMarshaler" compiler error signifies that the base type have changed.
	// Re-run the go-enum command to generate them again.
	var _ encoding.TextMarshaler = _nil_Icon_value

	// An "cannot convert Icon literal (type Icon) to type encoding.TextUnmarshaler" compiler error signifies that the base type have changed.
	// Re-run the go-enum command to generate them again.
	var _ encoding.TextUnmarshaler = &_nil_Icon_value
}

// MarshalText implements the encoding.TextMarshaler interface for Icon
func (i Icon) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the encoding.TextUnmarshaler interface for Icon
func (i *Icon) UnmarshalText(text []byte) error {
	var err error
	*i, err = ParseIconString(string(text))
	return err
}

//func _() {
//	var _nil_Icon_value = func() (val Icon) { return }()
//
//	// An "cannot convert Icon literal (type Icon) to type yaml.Marshaler" compiler error signifies that the base type have changed.
//	// Re-run the go-enum command to generate them again.
//	var _ yaml.Marshaler = _nil_Icon_value
//
//	// An "cannot convert Icon literal (type Icon) to type yaml.Unmarshaler" compiler error signifies that the base type have changed.
//	// Re-run the go-enum command to generate them again.
//	var _ yaml.Unmarshaler = &_nil_Icon_value
//}

// MarshalYAML implements a YAML Marshaler for Icon
func (i Icon) MarshalYAML() (interface{}, error) {
	return i.String(), nil
}

// UnmarshalYAML implements a YAML Unmarshaler for Icon
func (i *Icon) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var s string
	if err := unmarshal(&s); err != nil {
		return err
	}

	var err error
	*i, err = ParseIconString(s)
	return err
}

func _() {
	var _nil_Icon_value = func() (val Icon) { return }()

	// An "cannot convert Icon literal (type Icon) to type driver.Valuer" compiler error signifies that the base type have changed.
	// Re-run the go-enum command to generate them again.
	var _ driver.Valuer = _nil_Icon_value

	// An "cannot convert Icon literal (type Icon) to type sql.Scanner" compiler error signifies that the base type have changed.
	// Re-run the go-enum command to generate them again.
	var _ sql.Scanner = &_nil_Icon_value
}

func (i Icon) Value() (driver.Value, error) {
	return i.String(), nil
}

func (i *Icon) Scan(value interface{}) error {
	if value == nil {
		return nil
	}

	str, ok := value.(string)
	if !ok {
		bytes, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("value is not a byte slice")
		}

		str = string(bytes[:])
	}

	val, err := ParseIconString(str)
	if err != nil {
		return err
	}

	*i = val
	return nil
}

// IconSliceContains reports whether sunEnums is within enums.
func IconSliceContains(enums []Icon, sunEnums ...Icon) bool {
	var seenEnums = map[Icon]bool{}
	for _, e := range sunEnums {
		seenEnums[e] = false
	}

	for _, v := range enums {
		if _, has := seenEnums[v]; has {
			seenEnums[v] = true
		}
	}

	for _, seen := range seenEnums {
		if !seen {
			return false
		}
	}

	return true
}

// IconSliceContainsAny reports whether any sunEnum is within enums.
func IconSliceContainsAny(enums []Icon, sunEnums ...Icon) bool {
	var seenEnums = map[Icon]struct{}{}
	for _, e := range sunEnums {
		seenEnums[e] = struct{}{}
	}

	for _, v := range enums {
		if _, has := seenEnums[v]; has {
			return true
		}
	}

	return false
}
