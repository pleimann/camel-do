package timeline

import (
	"fmt"
	"github.com/pleimann/camel-do/model"
	"github.com/pleimann/camel-do/templates/components"
	"slices"
	"time"
)

// TimelineConfig holds configuration for timeline display
type TimelineConfig struct {
	StartHour   int
	EndHour     int
	SlotMinutes int
	ZoomLevel   float64
}

// DefaultTimelineConfig returns default timeline configuration
func DefaultTimelineConfig() *TimelineConfig {
	return &TimelineConfig{
		StartHour:   6,
		EndHour:     24,
		SlotMinutes: 15,
		ZoomLevel:   1.0,
	}
}


func slotCount(config *TimelineConfig) int {
    return (config.EndHour - config.StartHour) * (60 / config.SlotMinutes) - 1
}

const TIMELINE_COLUMNS = 2

// detectOverlaps finds overlapping tasks/events and assigns column positions and spans
func detectOverlaps(items []TimelineItem) []TimelineItem {
	if len(items) == 0 {
		return items
	}

	// Sort by start time
	slices.SortFunc(items, func(a, b TimelineItem) int {
		return a.StartTime.Compare(b.StartTime)
	})

	// First pass: assign columns as before
	var active []TimelineItem
	maxColumn := 0

	for i := range items {
		item := &items[i]

		// Remove items that have ended
		active = slices.DeleteFunc(active, func(activeItem TimelineItem) bool {
			return activeItem.EndTime.Before(item.StartTime) ||
				   activeItem.EndTime.Equal(item.StartTime)
		})

		// Find available column
		item.Column = 0
		for col := 0; col <= maxColumn+1; col++ {
			available := true
			for _, activeItem := range active {
				if activeItem.Column == col {
					available = false
					break
				}
			}
			if available {
				item.Column = col
				break
			}
		}

		if item.Column > maxColumn {
			maxColumn = item.Column
		}

		active = append(active, *item)
	}

	// Second pass: calculate spans based on overlap groups
	for i := range items {
		item := &items[i]
		
		// Find all items that overlap with this item
		overlappingItems := []TimelineItem{*item}
		for j := range items {
			if i == j {
				continue
			}
			other := &items[j]
			
			// Check for time overlap
			if item.StartTime.Before(other.EndTime) && item.EndTime.After(other.StartTime) {
				overlappingItems = append(overlappingItems, *other)
			}
		}
		
		// Calculate span: if no overlaps, use full width (5 columns)
		// If overlaps exist, distribute width among overlapping items
		if len(overlappingItems) == 1 {
			// No overlaps - use full width
			item.Span = TIMELINE_COLUMNS
		} else {
			// Has overlaps - calculate appropriate span
			maxOverlapColumn := 0
			for _, overlapping := range overlappingItems {
				if overlapping.Column > maxOverlapColumn {
					maxOverlapColumn = overlapping.Column
				}
			}
			
			// Distribute the 5 available columns among overlapping items
			columnsPerItem := 5 / (maxOverlapColumn + 1)
			if columnsPerItem < 1 {
				columnsPerItem = 1
			}
			
			item.Span = columnsPerItem
			
			// Ensure we don't exceed available space
			if item.Column + item.Span > TIMELINE_COLUMNS {
				item.Span = TIMELINE_COLUMNS - item.Column
			}
            
			if item.Span < 1 {
				item.Span = 1
			}
		}
	}

	return items
}

// TimelineItem represents a task or event with positioning info
type TimelineItem struct {
	ID          string
	Title       string
	StartTime   time.Time
	EndTime     time.Time
	Duration    int32
	ProjectID   string
	Column      int
	Span        int    // How many columns to span
	Type        string // "task" or "event"
}

// validateTimeConflicts checks for scheduling conflicts
func validateTimeConflicts(items []TimelineItem) []string {
	var conflicts []string

	for i, item1 := range items {
		for j, item2 := range items {
			if i >= j {
				continue
			}

			// Check for time overlap
			if (item1.StartTime.Before(item2.EndTime) && item1.EndTime.After(item2.StartTime)) ||
			   (item2.StartTime.Before(item1.EndTime) && item2.EndTime.After(item1.StartTime)) {
				conflicts = append(conflicts, fmt.Sprintf("Conflict: %s (%s) overlaps with %s (%s)",
					item1.Title, item1.Type, item2.Title, item2.Type))
			}
		}
	}

	return conflicts
}

func meridian(h24 int) string {
	if h24 >= 12 {
		return "PM"
	} else {
		return "AM"
	}
}

templ TimelineView(date time.Time, tasks *model.TaskList, events *model.EventList, projects *model.ProjectIndex, config *TimelineConfig) {
    {{
        if config == nil {
            config = DefaultTimelineConfig()
        }  
    }}

    <div id="timelineview" class="w-full">
        @components.DayOfWeekSelector(time.Monday, date, "#timelineview")

        {{
            // Convert tasks and events to TimelineItems for overlap detection
            var allItems []TimelineItem
            for task := range tasks.All() {
                allItems = append(allItems, TimelineItem{
                    ID:        task.ID,
                    Title:     task.Title.String,
                    StartTime: task.StartTime.Time,
                    EndTime:   calculateEndTime(task.StartTime.Time, task.Duration.Int32),
                    Duration:  task.Duration.Int32,
                    ProjectID: task.ProjectID.String,
                    Type:      "task",
                })
            }
            for event := range events.All() {
                allItems = append(allItems, TimelineItem{
                    ID:        event.ID,
                    Title:     event.Title.String,
                    StartTime: event.StartTime.Time,
                    EndTime:   calculateEndTime(event.StartTime.Time, event.Duration.Int32),
                    Duration:  event.Duration.Int32,
                    ProjectID: event.ProjectID.String,
                    Type:      "event",
                })
            }

            // Detect overlaps and assign columns
            allItems = detectOverlaps(allItems)

            // Validate for conflicts
            conflicts := validateTimeConflicts(allItems)

            // Group items by type for rendering
            var taskItems []TimelineItem
            var eventItems []TimelineItem
            for _, item := range allItems {
                if item.Type == "task" {
                    taskItems = append(taskItems, item)
                } else {
                    eventItems = append(eventItems, item)
                }
            }
        }}

        <!-- Conflict Toast Trigger -->
        if len(conflicts) > 0 {
            <div 
                x-data="{ showToast: false }"
                x-init="
                    showToast = true;
                    setTimeout(() => showToast = false, 10000);
                "
            >
                <!-- Toast Container -->
                <div class="toast toast-top toast-end z-50" x-show="showToast" x-transition>
                    <div class="alert alert-warning max-w-md shadow-lg">
                        <svg class="w-6 h-6 stroke-current shrink-0" fill="none" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.732 0L4.082 16.5c-.77.833.192 2.5 1.732 2.5z" />
                        </svg>
                        <div class="flex-1">
                            <h3 class="font-bold">Schedule Conflicts Detected!</h3>
                            <div class="text-sm mt-1 space-y-1">
                                for _, conflict := range conflicts {
                                    <div class="text-xs">{ conflict }</div>
                                }
                            </div>
                        </div>
                        <button class="btn btn-sm btn-ghost" @click="showToast = false">Ã—</button>
                    </div>
                </div>
            </div>
        }

        <div
            id="timeline"
            class="w-full max-h-[calc(100vh-160px)] overflow-y-scroll overflow-x-hidden"
            hx-ext="drag"
        >
            <!-- Timeline Grid Container -->
            <div id="timeline-grid" class={ "grid place-items-stretch grid-flow-col-dense gap-x-1 p-2"}
                style={
                    fmt.Sprintf("grid-template-rows: %d;", slotCount(config)),
                    fmt.Sprintf("grid-template-columns: 2rem 8px repeat(%d, 1fr);", TIMELINE_COLUMNS)
                }
                x-sort.ghost="handleDrag"
            >
                @TimelineGridContent(date, tasks, events, projects, config)
            </div>
        </div>
    </div>
}

