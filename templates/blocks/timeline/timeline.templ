package timeline

import (
	"fmt"
	"github.com/pleimann/camel-do/model"
	"github.com/pleimann/camel-do/templates/components"
	"math"
	"slices"
	"strings"
	"time"
)

// TimelineConfig holds configuration for timeline display
type TimelineConfig struct {
	StartHour   int
	EndHour     int
	SlotMinutes int
	ZoomLevel   float64
}

// DefaultTimelineConfig returns default timeline configuration
func DefaultTimelineConfig() *TimelineConfig {
	return &TimelineConfig{
		StartHour:   6,
		EndHour:     24,
		SlotMinutes: 15,
		ZoomLevel:   1.0,
	}
}

// calculateTimePosition calculates precise grid position for a task/event
func calculateTimePosition(startTime time.Time, duration int32, config *TimelineConfig) (slot int, span int) {
	startHour := config.StartHour
	slotMins := config.SlotMinutes

	// Convert to local timezone for display
	localTime := startTime.Local()
	
	// Calculate total minutes from timeline start
	startMinutes := (localTime.Hour()-startHour)*60 + localTime.Minute()

	// Calculate slot position (1-based for CSS grid)
	slot = (startMinutes / slotMins) + 1

	// Calculate span based on duration
	durationMins := int(duration)
	if durationMins < slotMins {
		durationMins = slotMins // Minimum span of 1 slot
	}
	span = int(math.Ceil(float64(durationMins) / float64(slotMins)))

	return slot, span
}

// calculateEndTime calculates the end time of a task/event
func calculateEndTime(startTime time.Time, duration int32) time.Time {
	return startTime.Add(time.Duration(duration) * time.Minute)
}

// formatTimeRange formats start and end time for display
func formatTimeRange(startTime time.Time, duration int32) string {
	endTime := calculateEndTime(startTime, duration)
	
	// Convert to local timezone for display
	localStartTime := startTime.Local()
	localEndTime := endTime.Local()

	return fmt.Sprintf("%s - %s",
		localStartTime.Format("15:04"),
		localEndTime.Format("15:04"))
}

// formatDuration formats duration in human-readable format
func formatDuration(duration int32) string {
	if duration < 60 {
		return fmt.Sprintf("%dm", duration)
	}

	hours := duration / 60
	minutes := duration % 60
	if minutes == 0 {
		return fmt.Sprintf("%dh", hours)
	}
	
    return fmt.Sprintf("%dh %dm", hours, minutes)
}

func slotCount(config *TimelineConfig) int {
    return (config.EndHour - config.StartHour) * (60 / config.SlotMinutes) - 1
}

const TIMELINE_COLUMNS = 4

// detectOverlaps finds overlapping tasks/events and assigns column positions and spans
func detectOverlaps(items []TimelineItem) []TimelineItem {
	if len(items) == 0 {
		return items
	}

	// Sort by start time
	slices.SortFunc(items, func(a, b TimelineItem) int {
		return a.StartTime.Compare(b.StartTime)
	})

	// First pass: assign columns as before
	var active []TimelineItem
	maxColumn := 0

	for i := range items {
		item := &items[i]

		// Remove items that have ended
		active = slices.DeleteFunc(active, func(activeItem TimelineItem) bool {
			return activeItem.EndTime.Before(item.StartTime) ||
				   activeItem.EndTime.Equal(item.StartTime)
		})

		// Find available column
		item.Column = 0
		for col := 0; col <= maxColumn+1; col++ {
			available := true
			for _, activeItem := range active {
				if activeItem.Column == col {
					available = false
					break
				}
			}
			if available {
				item.Column = col
				break
			}
		}

		if item.Column > maxColumn {
			maxColumn = item.Column
		}

		active = append(active, *item)
	}

	// Second pass: calculate spans based on overlap groups
	for i := range items {
		item := &items[i]
		
		// Find all items that overlap with this item
		overlappingItems := []TimelineItem{*item}
		for j := range items {
			if i == j {
				continue
			}
			other := &items[j]
			
			// Check for time overlap
			if item.StartTime.Before(other.EndTime) && item.EndTime.After(other.StartTime) {
				overlappingItems = append(overlappingItems, *other)
			}
		}
		
		// Calculate span: if no overlaps, use full width (5 columns)
		// If overlaps exist, distribute width among overlapping items
		if len(overlappingItems) == 1 {
			// No overlaps - use full width
			item.Span = TIMELINE_COLUMNS
		} else {
			// Has overlaps - calculate appropriate span
			maxOverlapColumn := 0
			for _, overlapping := range overlappingItems {
				if overlapping.Column > maxOverlapColumn {
					maxOverlapColumn = overlapping.Column
				}
			}
			
			// Distribute the 5 available columns among overlapping items
			columnsPerItem := 5 / (maxOverlapColumn + 1)
			if columnsPerItem < 1 {
				columnsPerItem = 1
			}
			
			item.Span = columnsPerItem
			
			// Ensure we don't exceed available space
			if item.Column + item.Span > 5 {
				item.Span = TIMELINE_COLUMNS - item.Column
			}
			if item.Span < 1 {
				item.Span = 1
			}
		}
	}

	return items
}

// TimelineItem represents a task or event with positioning info
type TimelineItem struct {
	ID          string
	Title       string
	StartTime   time.Time
	EndTime     time.Time
	Duration    int32
	ProjectID   string
	Column      int
	Span        int    // How many columns to span
	Type        string // "task" or "event"
}

// validateTimeConflicts checks for scheduling conflicts
func validateTimeConflicts(items []TimelineItem) []string {
	var conflicts []string

	for i, item1 := range items {
		for j, item2 := range items {
			if i >= j {
				continue
			}

			// Check for time overlap
			if (item1.StartTime.Before(item2.EndTime) && item1.EndTime.After(item2.StartTime)) ||
			   (item2.StartTime.Before(item1.EndTime) && item2.EndTime.After(item1.StartTime)) {
				conflicts = append(conflicts, fmt.Sprintf("Conflict: %s (%s) overlaps with %s (%s)",
					item1.Title, item1.Type, item2.Title, item2.Type))
			}
		}
	}

	return conflicts
}

func meridian(h24 int) string {
	if h24 >= 12 {
		return "PM"
	} else {
		return "AM"
	}
}

templ TimelineView(date time.Time, tasks *model.TaskList, events *model.EventList, projects *model.ProjectIndex, config *TimelineConfig) {
    {{
        if config == nil {
            config = DefaultTimelineConfig()
        }  
    }}

    <div id="timelineview" class="w-full">
        @components.DayOfWeekSelector(time.Monday, date, "#timelineview")

        {{
            // Convert tasks and events to TimelineItems for overlap detection
            var allItems []TimelineItem
            for task := range tasks.All() {
                allItems = append(allItems, TimelineItem{
                    ID:        task.ID,
                    Title:     task.Title.String,
                    StartTime: task.StartTime.Time,
                    EndTime:   calculateEndTime(task.StartTime.Time, task.Duration.Int32),
                    Duration:  task.Duration.Int32,
                    ProjectID: task.ProjectID.String,
                    Type:      "task",
                })
            }
            for event := range events.All() {
                allItems = append(allItems, TimelineItem{
                    ID:        event.ID,
                    Title:     event.Title.String,
                    StartTime: event.StartTime.Time,
                    EndTime:   calculateEndTime(event.StartTime.Time, event.Duration.Int32),
                    Duration:  event.Duration.Int32,
                    ProjectID: event.ProjectID.String,
                    Type:      "event",
                })
            }

            // Detect overlaps and assign columns
            allItems = detectOverlaps(allItems)

            // Validate for conflicts
            conflicts := validateTimeConflicts(allItems)

            // Group items by type for rendering
            var taskItems []TimelineItem
            var eventItems []TimelineItem
            for _, item := range allItems {
                if item.Type == "task" {
                    taskItems = append(taskItems, item)
                } else {
                    eventItems = append(eventItems, item)
                }
            }
        }}

        <!-- Conflict Warnings -->
        if len(conflicts) > 0 {
            <div class="alert alert-warning mb-4">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.732 0L4.082 16.5c-.77.833.192 2.5 1.732 2.5z"></path>
                </svg>
                <div>
                    <h3 class="font-bold">Schedule Conflicts Detected!</h3>
                    <div class="text-sm">
                        for _, conflict := range conflicts {
                            <div>{ conflict }</div>
                        }
                    </div>
                </div>
            </div>
        }

        <div
            id="timeline"
            class="w-full max-h-[calc(100vh-160px)] overflow-y-scroll overflow-x-hidden"
            hx-ext="drag"
        >
            <!-- Timeline Grid Container -->
            <div class={ "grid place-items-stretch grid-flow-col-dense gap-x-1 p-2"}
                style={ 
                    fmt.Sprintf("grid-template-rows: %d;", slotCount(config)),
                    fmt.Sprintf("grid-template-columns: 2rem 8px repeat(%d, 1fr);", TIMELINE_COLUMNS)
                }
                x-sort.ghost="handleDrag"
            >
                <!-- Time Labels Column -->
                for h24 := config.StartHour; h24 < config.EndHour; h24++ {
                    {{
                        h := h24
                        if h24 > 12 {
                            h = h24 - 12
                        }
                        if h == 0 {
                            h = 12
                        }
                    }}

                    <!-- Hour marker -->
                    <div id={ fmt.Sprintf("tick-%d", h24) }
                        class="col-start-1 row-span-4 p-1 border-e border-t tabular-nums flex flex-col items-center"
                    >
                        <p class="text-xl font-bold block">{h}</p>
                        <p class="text-xs">{ meridian(h24) }</p>
                    </div>

                    <!-- Hour ticks -->
                    for m := 0; m < 60; m += config.SlotMinutes {
                        {{ s := ((h24 - config.StartHour) * (60 / config.SlotMinutes)) + (m / config.SlotMinutes) }}
                        <div
                            id={ fmt.Sprintf("tick-%d-%d", h24, m) }
                            x-data={ fmt.Sprintf("{hour: %d, minute: %d, slot: %d}", h, m, s) }
                            class="border-t min-h-12"
                        ></div>
                    }
                }

                <!-- Task Cards -->
                for _, taskItem := range taskItems {
                    // Find original task for additional data
                    for task := range tasks.All() {
                        if task.ID == taskItem.ID {
                            @timelineTaskCard(task, taskItem, projects, config)
                        }
                    }
                }

                <!-- Event Cards -->
                for _, eventItem := range eventItems {
                    // Find original event for additional data
                    for event := range events.All() {
                        if event.ID == eventItem.ID {
                            @timelineEventCard(event, eventItem, projects, config)
                        }
                    }
                }
            </div>
        </div>
    </div>
}

templ timelineTaskCard(task model.Task, taskItem TimelineItem, projects *model.ProjectIndex, config *TimelineConfig) {
	{{
        project := projects.Get(task.ProjectID.String)
        color := strings.ToLower(project.Color.String())
        slot, span := calculateTimePosition(task.StartTime.Time, task.Duration.Int32, config)

        position := map[string]string{
            "grid-row":    fmt.Sprintf("%d / span %d", slot, span),
            "grid-column": fmt.Sprintf("%d / span %d", 3+taskItem.Column, taskItem.Span),
            "max-height":  fmt.Sprintf("%.1frem", 3 * float64(span) * config.ZoomLevel),
        }
	}}

    // Enhanced task card with detailed time information
    <div
        id={ fmt.Sprintf("task-bar-%s", task.ID) }
        class={
            "h-full", "flex", "items-start", "rounded-xl", "cursor-pointer", "border",
            fmt.Sprintf("bg-%s-200", color), fmt.Sprintf("text-%s-800", color), fmt.Sprintf("border-%s-800", color),
        }
        style={ position }
    >
        <div class="p-2">
            @components.Icon(project.Icon, 8)
        </div>
        <div class="p-1 grow">
            <div class="font-medium truncate">{ task.Title.String }</div>
            <div class="text-xs opacity-75">
                { fmt.Sprintf("%s (%s)", task.StartTime.Time.Local().Format("15:04"), formatDuration(task.Duration.Int32)) }
            </div>
        </div>
    </div>
}

templ timelineEventCard(event model.Event, eventItem TimelineItem, projects *model.ProjectIndex, config *TimelineConfig) {
	{{
        project := projects.Get(event.ProjectID.String)
        color := strings.ToLower(project.Color.String())
        slot, span := calculateTimePosition(event.StartTime.Time, event.Duration.Int32, config)

        position := map[string]string{
            "grid-row":    fmt.Sprintf("%d / span %d", slot, span),
            "grid-column": fmt.Sprintf("%d / span %d", 3+eventItem.Column, eventItem.Span),
            "max-height":  fmt.Sprintf("%.1frem", 3*float64(span)*config.ZoomLevel),
        }
	}}

    // Enhanced event card with detailed time information
    <div
        id={ fmt.Sprintf("event-bar-%s", event.ID) }
        class={
            "h-full", "flex", "items-start", "rounded-xl", "cursor-pointer", "border",
            fmt.Sprintf("bg-%s-200", color), fmt.Sprintf("text-%s-800", color), fmt.Sprintf("border-%s-800", color),
        }
        style={ position }
    >
        <div class="p-2">
            @components.Icon(project.Icon, 8)
        </div>
        <div class="p-1 grow">
            <div class="font-medium truncate">{ event.Title.String }</div>
            <div class="text-xs opacity-75">
                { fmt.Sprintf("%s (%s)", event.StartTime.Time.Local().Format("15:04"), formatDuration(event.Duration.Int32)) }
            </div>
        </div>
    </div>
}
